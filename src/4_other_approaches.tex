\chapter{Other Approaches}
\label{chap:otherapproaches}
In this section, we describe both the Linux reference implementation of LUKS2 and the two disk encryption technologies that are featured in the performance comparison in \autoref{chap:performance}.

\section{Linux Kernel Implementation of LUKS2}
\label{chap:otherapproaches.linux}
To compare the architecture of our driver (see \autoref{chap:ourapproach.final}) to that of the Linux reference implementation, the latter will be described in this section. \todo{To see how the userspace part}\\\todo{of this implementation works, we will take a look at the source code of the \texttt{cryptsetup} tool.} The work of looking through the Linux kernel source code and creating a high-level overview has already been done in \cite{Korchagin2020}.

\subsection{The Linux Kernel Device Mapper}
\label{chap:otherapproaches.linux.dm}
The reference implementation uses the Linux kernel's Device Mapper \cite{Dmcrypt2020}. This is a kernel driver that allows creating virtual devices in layers. One such layer is known as a \emph{target}. A layer can be thought of as the Linux equivalent of a Windows file system filter driver\footnote{\label{fn:otherapproaches.linux.dmtargetdriver} This comparison holds as far as that the functionality of target is implemented by a kernel driver. It is also possible to implement new targets, as done e.g. in \cite{Barker2019}.}. The device mapper comes with many different available targets, including \cite{Linux}:
\begin{descitemize}
	\item[\texttt{zero}] This target always returns zeroes for all reads and silently discards all writes. It is similar to Linux' \texttt{/dev/zero}, but in contrast to that this is a block device, not a character device\footnote{\label{fn:otherapproaches.linux.charvsblock} The difference is that character devices read and write a stream of individual byes, and block devices read and write blocks (usually 512 bytes) \cite{Corbet2005}.}.
	\item[\texttt{linear}] This target maps a range of blocks of the virtual device to an existing device. Described in more detail: ``map the block range $N$ to $N+L$ of the virtual device to the block range $M$ to $M+L$ of device $X$''.
	\item[\texttt{snapshot}] This target creates a copy-on-write snapshot of a device. These snapshots are ``mountable, saved states of the block device which are also writable without interfering with the original content.'' \cite{Linux}
	\item[\texttt{crypt}] This target performs transparent encryption of a device (writes are encrypted, reads are decrypted). This is what the LUKS2 reference implementation uses. The encryption is done via the Linux Kernel Crypto API, which offers a variety of different encryption schemes. This interface is described in more detail in \cite{Linux}.
\end{descitemize}

The configuration of a virtual device happens via a \emph{mapping table}. The general format is described in \autoref{fig:otherapproaches.linux.mappingtable}, and \autoref{fig:otherapproaches.linux.dmcryptparameters} describes the parameter format for the \texttt{crypt} target.

Outside of the mapping table, the device mapper's targets are usually written with the \texttt{dm-} prefix, e.g. we write \texttt{dm-crypt} for the \texttt{crypt} target.

\begin{figure}[htb!]
	\center
	\begin{mdframed}
		\texttt{<start block> <size> <target name> <target parameters>}
	\end{mdframed}
	\caption[
		Linux device mapper mapping table entry format
	]{
		Linux device mapper mapping table entry format (modified after \cite{Dmcrypt2020}). The \texttt{start block} is the first block of the virtual device that this mapping applies to. \texttt{size} indicates the number of blocks, including the start block, that this mapping is for. \texttt{target name} specifies the device mapper target that will be used. The \texttt{target parameters} are specific to each of the different targets. The \texttt{crypt} target's parameters are described in \autoref{fig:otherapproaches.linux.dmcryptparameters}.\\
		The full mapping for a virtual device can contain multiple entries, each in its own line. It is possible to combine different targets. The following example shows a 1024 block virtual device, whose first half is mapped using the \texttt{linear} target, and whose second half is mapped using the \texttt{crypt} target:\\
		\texttt{0\space\space\space{}512 linear <linear parameters>}\\
		\texttt{512 512 crypt\space\space{}<crypt parameters>}
	}
	\label{fig:otherapproaches.linux.mappingtable}
\end{figure}

\begin{figure}[htb!]
	\center
	\begin{mdframed}
		\texttt{<cipher> <key> <iv offset> <device path> <offset> [<\#opt> <opt> <...>]}
	\end{mdframed}
	\caption[
		\texttt{dm-crypt} target parameter format
	]{
		\texttt{dm-crypt} target parameter format (modified after \cite{Dmcrypt2020}). \texttt{cipher} specifies the encryption cipher that is used, in the following format: \texttt{cipher-chainmode-ivmode[:ivopts]}. See \autoref{chap:background.luks2.using} for more on ciphers, chain modes (also known as block cipher modes), and IVs. \autoref{tbl:background.luks2.encryptionalgorithms} also lists examples of available encryption algorithms. \texttt{key} is the key used for the specified cipher. It can either be in hexadecimal notation, or a reference to a key in the kernel keyring (more on this shortly). The \texttt{iv offset} is a constant offset that is added to the sector number to create the IV. The \texttt{device path} determines the device the encrypted data is stored on, either by giving its path (e.g. \texttt{/dev/sda1}) or its major and minor number (e.g. \texttt{8:16}, see \cite{Corbet2005} for more on these). The \texttt{offset} gives the first sector on the specified device containing the encrypted data. Additionally, optional parameters can be specified after these required parameters, e.g. the disk's sector size, preceded by the count of optional parameters.
	}
	\label{fig:otherapproaches.linux.dmcryptparameters}
\end{figure}

\autoref{fig:otherapproaches.linux.dmcryptparameters} mentioned the \emph{kernel keyring} (also known as the kernel key retention service). It is provided by the Linux kernel to cache keys and other secrets for usage by other kernel components. Keys have different attributes, including a key type, a name (also called a description), and a unique serial number. Depending on the key type and a user's permissions, keys can also be accessed from user space using that serial. The serial can be obtained by searching for a key using its type and name. Kernel services can register new key types, supplementary to some already defined types. These include \cite{Linux}\cite{ManKeyrings}:
\begin{descitemize}
	\item[\texttt{keyring}] A key of this type contains a list of links to other keys, including other keyrings.
	\item[\texttt{user}] A key of this type contains a payload of arbitrary binary data (up to 32767 bytes) and can be accessed and modified from user space. Because of this, keys of this type are not intended to be used by the kernel.
	\item[\texttt{logon}] This is similar to the \texttt{user} type, but keys of this type can only be read by the kernel. It is however possible to create or update them from user space. A \texttt{logon} key's description must start with a prefix followed by a colon, with the prefix denoting which service the key belongs to.
\end{descitemize}

The format of the \texttt{key} parameter from \autoref{fig:otherapproaches.linux.dmcryptparameters} when using the kernel keyring is: \texttt{:<size>:<type>:<description>}. \texttt{size} is the key size in bytes, and \texttt{type} and \texttt{description} are the key's type and description, respectively \cite{Dmcrypt2020}. See \autoref{chap:otherapproaches.linux.cryptsetup} for an example. \todo{more precise ref available?}

As already mentioned, \texttt{dm-crypt} uses the Linux kernel's Crypto API for the de-/encryption of reads and writes. \autoref{fig:otherapproaches.linux.dmcryptio} shows the flow of I/O operations through different parts of \texttt{dm-crypt} and the Crypto API. \cite{Korchagin2020} experimented with skipping some of the queues shown in the figure, and found significantly increased throughput for some hardware configurations and use cases. They therefore implemented the possibility to configure \texttt{dm-crypt} to queue less operations. This is done via optional parameters (see \autoref{fig:otherapproaches.linux.dmcryptparameters}), and can be used since Linux 5.9 \cite{Dmcrypt2020}.

\begin{figure}[htb!]
	\center
	\small
	\begin{tikzpicture}[
		read/.style={
			arrow,
			very thick,
			draw=tBlue,
		},
		write/.style={
			arrow,
			very thick,
			draw=tPink,
		},
	]
		\node[rect, dashed, rounded corners=10pt, from={0, 1.5 to 6.5,  7}] {};
		\node[rect, dashed, rounded corners=10pt, from={8, 1.5 to 14.5, 7}] {};

		\foreach \x\y in {2.25/6,2.25/2,4/4,10.4/5.4,10.2/5.2,10/5} {
			\node[rect, draw=gray!70, fill=gray!30, minimum width=0.5cm, minimum height=0.5cm] at (\x,     \y) {};
			\node[rect, draw=gray!70, fill=gray!30, minimum width=0.5cm, minimum height=0.5cm] at (\x+0.5, \y) {};
			\node[rect, draw=gray!70, fill=gray!30, minimum width=0.5cm, minimum height=0.5cm] at (\x+1.0, \y) {};
			\node[rect, draw=gray!70, fill=gray!30, minimum width=0.5cm, minimum height=0.5cm] at (\x+1.5, \y) {};
		}

		\node[rect, draw=gray!70, fill=gray!30, from={1,    4   to 1.5,  4.5}] {};
		\node[rect, draw=gray!70, fill=red,     from={0.75, 3.5 to 1.25, 4}]   {};
		\node[rect, draw=gray!70, fill=black,   from={1.25, 3.5 to 1.75, 4}]   {};

		\node at (1.25,  4.75) {write\_tree};
		\node at (3,     2.5)  {dmcrypt\_write};
		\node at (3,     6.5)  {kcryptd\_io};
		\node at (4.7,   4.5)  {kcryptd};
		\node at (11.15, 5.9)  {cryptd};

		\node[anchor=north west, xshift=2pt, yshift=-2pt] at (0, 7) {\footnotesize\textit{dm-crypt}};
		\node[anchor=north west, xshift=2pt, yshift=-2pt] at (8, 7) {\footnotesize\textit{Crypto API}};

		\node[rect, fill=tOrng, rounded corners=4pt, from={4.75, 7.5 to 9.75, 8.5}] (fs)  {File system driver};
		\node[rect, fill=tPurp, rounded corners=4pt, from={4.75, 0   to 9.75, 1}]   (dev) {Device driver};

		\draw[read] (fs.west)    -| (4.375, 6)    -- (4, 6);
		\draw[read] (3, 5.75)    -- (3, 3)        -| (5.25, 1);
		\draw[read] (dev.east)   -| (10.25, 3.25) -| (4.75, 3.75);
		\draw[read] (5.5, 3.75)  -- (5.5, 3.5)    -| (11.5, 4.75);
		\draw[read] (11.9, 5.65) |- (fs.east);
		\node[anchor=east] at (4.375, 8) {\textcolor{tBlue!90!black}{read}};

		\draw[write] (fs.south)   |- (5.5, 5.875) -- (5.5, 4.25);
		\draw[write] (5.75, 4)    -| (10.5, 4.75);
		\draw[write] (9.75, 5)    -- (3.25, 5)    |- (1.5, 4.25);
		\draw[write] (1.25, 3.5)  |- (2, 2);
		\draw[write] (3.75, 1.75) |- (dev.west);
		\node[anchor=north west] at (fs.south) {\textcolor{tPink!90!black}{write}};
	\end{tikzpicture}
	\caption[
		\texttt{dm-crypt} and Linux kernel crypto IO traverse path
	]{
		\texttt{dm-crypt} and Linux kernel crypto IO traverse path (modified after \cite{Korchagin2020}). A write request from the file system driver first moves into the \texttt{kcryptd} workqueue. This queue takes care of doing the encryption at some later, more convenient point in time (see \cite{Linux} for more details). The Linux kernel crypto API does the actual encryption work, and it also may use internal queues. The encrypted write requests are then sorted by \texttt{dm-crypt} using a red-black tree and are sent to the device driver via another workqueue. \\
		For read requests, the encrypted data is retrieved from the device driver using the \texttt{kcryptd\_io} workqueue. When this data arrives, it is scheduled for decryption in the already mentioned \texttt{kcryptd} queue. When the kernel crypto API has done its work, the decrypted data is ready for the file system driver.
	}
	\label{fig:otherapproaches.linux.dmcryptio}
\end{figure}

\subsection{The \texttt{cryptsetup} Command Line Utility}
\label{chap:otherapproaches.linux.cryptsetup}
Manually configuring the device mapper to work with encrypted partitions is impractical. Therefore, \texttt{dm-crypt} is accompanied by the \texttt{cryptsetup} command line utility. Its purpose is, given an encrypted volume, to automatically generate the appropriate \texttt{dm-crypt} configuration and send it to the kernel. It supports multiple different encryption technologies, including \cite{ManCryptsetup}:
\begin{itemize}
	\item LUKS and LUKS2 (see \autoref{chap:background.luks2});
	\item TrueCrypt and VeraCrypt (see \autoref{chap:otherapproaches.veracrypt});
	\item BitLocker (see \autoref{chap:otherapproaches.bitlocker}). This mode is relatively new and still in experimental status.
\end{itemize}

For LUKS and LUKS2, there is additional functionality available, including formatting new partitions, upgrading a LUKS partition to LUKS2, and adding new keyslots (these are explained in \autoref{chap:background.luks2}) \cite{ManCryptsetup}.

\todo{describe usual workflow of \texttt{cryptsetup} (luksFormat, open, close)}

In a simple use case the LUKS2 device contains only one encrypted segment. The whole mapping table then consists of just one line.\\\todo{\texttt{cryptsetup}'s purpose is to generate that line and send it to the device mapper.}

By default, \texttt{cryptsetup} uses the Linux kernel keyring \todo{cite man page with --disable cli option?}. It uses the ``logon'' key type, which means that the key can only be read by the kernel and not by other user space programs \todo{mention how we got that info, list relevant source code files and lines, show examples}. If explicitly instructed to do so, \texttt{cryptsetup} can also send the key directly to \texttt{dm-crypt}.

\todo{cite the following source code locations?}\\
all references are to the version of commit \texttt{ec946b17eb4aec48cbd4b3fc4b77324d4f5f8770}
\begin{itemize}
	\item lib/luks2\_digest.c, l. 411: shows the format of the key description -- the prefix is cryptsetup, the rest is the device uuid plus the digest index
	\item lib/setup.c, l. 6081 adds a key to the keyring (shows that the logon type is used)
	\item lib/libdevmapper.c, l. 671 shows the format of the complete key reference
	\item lib/utils\_safe\_memory.c, l. 35f. is the implementation of crypt\_safe\_memzero()
	\item lib/luks2/luk2\_json\_metadata.c, l. 2221 calls dm\_targets\_free(), which, via some other calls, calls crypt\_safe\_memzero() for the volume key
	\item different error paths also zero out the memory, e.g. lib/luks2/luks2\_keyslow.c, l. 343
\end{itemize}

After creating the \texttt{dm-crypt} device, the key data that is still resident in user space memory is overwritten with zeroes. \todo{mention relevant source code files and lines}

\section{VeraCrypt}
\label{chap:otherapproaches.veracrypt}

\section{BitLocker}
\label{chap:otherapproaches.bitlocker}
\todo{\cite{Kornblum2009} and \cite{Lewis2018} and \cite{Tuerpe2009} and \cite{Tan2020}}

\todo{\texttt{cryptsetup} has experimental support for BitLocker}

\todo{Use Ghidra and look at some of the code of \texttt{fvevol.sys}?}