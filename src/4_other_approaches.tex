\chapter{Other Approaches}
\label{chap:otherapproaches}
In this section, we describe both the Linux reference implementation of LUKS2 and the two disk encryption technologies that are featured in the performance comparison in \autoref{chap:performance}.

\section{Linux Kernel Implementation of LUKS2}
\label{chap:otherapproaches.linux}
To compare the architecture of our driver (see \autoref{chap:ourapproach.final}) to that of the Linux reference implementation, the latter will be described in this section. To see how the user space part of this implementation works, we will take a look at the source code of the \texttt{cryptsetup} tool. The work of looking through the Linux kernel source code and creating a high-level overview has already been done in \cite{Korchagin2020}.

\subsection{The Linux Kernel Device Mapper}
\label{chap:otherapproaches.linux.dm}
The reference implementation uses the Linux kernel's Device Mapper \cite{Dmcrypt2020}. This is a kernel driver that allows creating virtual devices in layers. One such layer is known as a \emph{target}. A layer can be thought of as the Linux equivalent of a Windows file system filter driver\footnote{\label{fn:otherapproaches.linux.dmtargetdriver} This comparison holds as far as that the functionality of target is implemented by a kernel driver. It is also possible to implement new targets, as done e.g. in \cite{Barker2019}.}. The device mapper comes with many different available targets, including \cite{Linux}:
\begin{descitemize}
	\item[\texttt{zero}] This target always returns zeroes for all reads and silently discards all writes. It is similar to Linux' \texttt{/dev/zero}, but in contrast to that this is a block device, not a character device\footnote{\label{fn:otherapproaches.linux.charvsblock} The difference is that character devices read and write a stream of individual byes, and block devices read and write blocks (usually 512 bytes) \cite{Corbet2005}.}.
	\item[\texttt{linear}] This target maps a range of blocks of the virtual device to an existing device. Described in more detail: ``map the block range $N$ to $N+L$ of the virtual device to the block range $M$ to $M+L$ of device $X$''.
	\item[\texttt{snapshot}] This target creates a copy-on-write snapshot of a device. These snapshots are ``mountable, saved states of the block device which are also writable without interfering with the original content.'' \cite{Linux}
	\item[\texttt{crypt}] This target performs transparent encryption of a device (writes are encrypted, reads are decrypted). This is what the LUKS2 reference implementation uses. The encryption is done via the Linux Kernel Crypto API, which offers a variety of different encryption schemes. This interface is described in more detail in \cite{Linux}.
\end{descitemize}

The configuration of a virtual device happens via a \emph{mapping table}. The general format is described in \autoref{fig:otherapproaches.linux.mappingtable}, and \autoref{fig:otherapproaches.linux.dmcryptparameters} describes the parameter format for the \texttt{crypt} target.

Outside of the mapping table, the device mapper's targets are usually written with the \texttt{dm-} prefix, e.g. we write \texttt{dm-crypt} for the \texttt{crypt} target.

\begin{figure}[htb!]
	\center
	\begin{mdframed}
		\texttt{<start block> <size> <target name> <target parameters>}
	\end{mdframed}
	\caption[
		Linux device mapper mapping table entry format
	]{
		Linux device mapper mapping table entry format (modified after \cite{Dmcrypt2020}). The \texttt{start block} is the first block of the virtual device that this mapping applies to. \texttt{size} indicates the number of blocks, including the start block, that this mapping is for. \texttt{target name} specifies the device mapper target that will be used. The \texttt{target parameters} are specific to each of the different targets. The \texttt{crypt} target's parameters are described in \autoref{fig:otherapproaches.linux.dmcryptparameters}.\\
		The full mapping for a virtual device can contain multiple entries, each in its own line. It is possible to combine different targets. The following example shows a 1024 block virtual device, whose first half is mapped using the \texttt{linear} target, and whose second half is mapped using the \texttt{crypt} target:\\
		\texttt{0\space\space\space{}512 linear <linear parameters>}\\
		\texttt{512 512 crypt\space\space{}<crypt parameters>}
	}
	\label{fig:otherapproaches.linux.mappingtable}
\end{figure}

\begin{figure}[htb!]
	\center
	\begin{mdframed}
		\texttt{<cipher> <key> <iv offset> <device path> <offset> [<\#opt> <opt> <...>]}
	\end{mdframed}
	\caption[
		\texttt{dm-crypt} target parameter format
	]{
		\texttt{dm-crypt} target parameter format (modified after \cite{Dmcrypt2020}). \texttt{cipher} specifies the encryption cipher that is used, in the following format: \texttt{cipher-chainmode-ivmode[:ivopts]}. See \autoref{chap:background.luks2.using} for more on ciphers, chain modes (also known as block cipher modes), and IVs. \autoref{tbl:background.luks2.encryptionalgorithms} also lists examples of available encryption algorithms. \texttt{key} is the key used for the specified cipher. It can either be in hexadecimal notation, or a reference to a key in the kernel keyring (more on this shortly). The \texttt{iv offset} is a constant offset that is added to the sector number to create the IV. The \texttt{device path} determines the device the encrypted data is stored on, either by giving its path (e.g. \texttt{/dev/sda1}) or its major and minor number (e.g. \texttt{8:16}, see \cite{Corbet2005} for more on these). The \texttt{offset} gives the first sector on the specified device containing the encrypted data. Additionally, optional parameters can be specified after these required parameters, e.g. the disk's sector size, preceded by the count of optional parameters.
	}
	\label{fig:otherapproaches.linux.dmcryptparameters}
\end{figure}

\autoref{fig:otherapproaches.linux.dmcryptparameters} mentioned the \emph{kernel keyring} (also known as the kernel key retention service). It is provided by the Linux kernel to cache keys and other secrets for usage by other kernel components. Keys have different attributes, including a key type, a name (also called a description), and a unique serial number. Depending on the key type and a user's permissions, keys can also be accessed from user space using that serial. The serial can be obtained by searching for a key using its type and name. Kernel services can register new key types, supplementary to some already defined types. These include \cite{Linux}\cite{ManKeyrings}:
\begin{descitemize}
	\item[\texttt{keyring}] A key of this type contains a list of links to other keys, including other keyrings.
	\item[\texttt{user}] A key of this type contains a payload of arbitrary binary data (up to 32767 bytes) and can be accessed and modified from user space. Because of this, keys of this type are not intended to be used by the kernel.
	\item[\texttt{logon}] This is similar to the \texttt{user} type, but keys of this type can only be read by the kernel. It is however possible to create or update them from user space. A \texttt{logon} key's description must start with a prefix followed by a colon, with the prefix denoting which service the key belongs to.
\end{descitemize}

The format of the \texttt{key} parameter from \autoref{fig:otherapproaches.linux.dmcryptparameters} when using the kernel keyring is: \texttt{:<size>:<type>:<description>}. \texttt{size} is the key size in bytes, and \texttt{type} and \texttt{description} are the key's type and description, respectively \cite{Dmcrypt2020}. See \autoref{chap:otherapproaches.linux.cryptsetup} for an example value of this parameter, created by the \texttt{cryptsetup} tool.

As already mentioned, \texttt{dm-crypt} uses the Linux kernel's Crypto API for the de-/encryption of reads and writes. \autoref{fig:otherapproaches.linux.dmcryptio} shows the flow of I/O operations through different parts of \texttt{dm-crypt} and the Crypto API. \cite{Korchagin2020} experimented with skipping some of the queues shown in the figure, and found significantly increased throughput for some hardware configurations and use cases. They therefore implemented the possibility to configure \texttt{dm-crypt} to queue less operations. This is done via optional parameters (see \autoref{fig:otherapproaches.linux.dmcryptparameters}), and can be used since Linux 5.9 \cite{Dmcrypt2020}.

\begin{figure}[htb!]
	\center
	\small
	\begin{tikzpicture}[
		read/.style={
			arrow,
			very thick,
			draw=tBlue,
		},
		write/.style={
			arrow,
			very thick,
			draw=tPink,
		},
	]
		\node[rect, dashed, rounded corners=10pt, from={0, 1.5 to 6.5,  7}] {};
		\node[rect, dashed, rounded corners=10pt, from={8, 1.5 to 14.5, 7}] {};

		\foreach \x\y in {2.25/6,2.25/2,4/4,10.4/5.4,10.2/5.2,10/5} {
			\node[rect, draw=gray!70, fill=gray!30, minimum width=0.5cm, minimum height=0.5cm] at (\x,     \y) {};
			\node[rect, draw=gray!70, fill=gray!30, minimum width=0.5cm, minimum height=0.5cm] at (\x+0.5, \y) {};
			\node[rect, draw=gray!70, fill=gray!30, minimum width=0.5cm, minimum height=0.5cm] at (\x+1.0, \y) {};
			\node[rect, draw=gray!70, fill=gray!30, minimum width=0.5cm, minimum height=0.5cm] at (\x+1.5, \y) {};
		}

		\node[rect, draw=gray!70, fill=gray!30, from={1,    4   to 1.5,  4.5}] {};
		\node[rect, draw=gray!70, fill=red,     from={0.75, 3.5 to 1.25, 4}]   {};
		\node[rect, draw=gray!70, fill=black,   from={1.25, 3.5 to 1.75, 4}]   {};

		\node at (1.25,  4.75) {write\_tree};
		\node at (3,     2.5)  {dmcrypt\_write};
		\node at (3,     6.5)  {kcryptd\_io};
		\node at (4.7,   4.5)  {kcryptd};
		\node at (11.15, 5.9)  {cryptd};

		\node[anchor=north west, xshift=2pt, yshift=-2pt] at (0, 7) {\footnotesize\textit{dm-crypt}};
		\node[anchor=north west, xshift=2pt, yshift=-2pt] at (8, 7) {\footnotesize\textit{Crypto API}};

		\node[rect, fill=tOrng, rounded corners=4pt, from={4.75, 7.5 to 9.75, 8.5}] (fs)  {File system driver};
		\node[rect, fill=tPurp, rounded corners=4pt, from={4.75, 0   to 9.75, 1}]   (dev) {Device driver};

		\draw[read] (fs.west)    -| (4.375, 6)    -- (4, 6);
		\draw[read] (3, 5.75)    -- (3, 3)        -| (5.25, 1);
		\draw[read] (dev.east)   -| (10.25, 3.25) -| (4.75, 3.75);
		\draw[read] (5.5, 3.75)  -- (5.5, 3.5)    -| (11.5, 4.75);
		\draw[read] (11.9, 5.65) |- (fs.east);
		\node[anchor=east] at (4.375, 8) {\textcolor{tBlue!90!black}{read}};

		\draw[write] (fs.south)   |- (5.5, 5.875) -- (5.5, 4.25);
		\draw[write] (5.75, 4)    -| (10.5, 4.75);
		\draw[write] (9.75, 5)    -- (3.25, 5)    |- (1.5, 4.25);
		\draw[write] (1.25, 3.5)  |- (2, 2);
		\draw[write] (3.75, 1.75) |- (dev.west);
		\node[anchor=north west] at (fs.south) {\textcolor{tPink!90!black}{write}};
	\end{tikzpicture}
	\caption[
		\texttt{dm-crypt} and Linux kernel crypto IO traverse path
	]{
		\texttt{dm-crypt} and Linux kernel crypto IO traverse path (modified after \cite{Korchagin2020}). A write request from the file system driver first moves into the \texttt{kcryptd} workqueue. This queue takes care of doing the encryption at some later, more convenient point in time (see \cite{Linux} for more details). The Linux kernel crypto API does the actual encryption work, and it also may use internal queues. The encrypted write requests are then sorted by \texttt{dm-crypt} using a red-black tree and are sent to the device driver via another workqueue. \\
		For read requests, the encrypted data is retrieved from the device driver using the \texttt{kcryptd\_io} workqueue. When this data arrives, it is scheduled for decryption in the already mentioned \texttt{kcryptd} queue. When the kernel crypto API has done its work, the decrypted data is ready for the file system driver.
	}
	\label{fig:otherapproaches.linux.dmcryptio}
\end{figure}

\subsection{The \texttt{cryptsetup} Command Line Utility}
\label{chap:otherapproaches.linux.cryptsetup}
Manually configuring the device mapper to work with encrypted partitions is impractical. Therefore, \texttt{dm-crypt} is accompanied by the \texttt{cryptsetup} command line utility. Its purpose is, given an encrypted volume, to automatically generate the appropriate \texttt{dm-crypt} configuration and send it to the kernel. It supports multiple different encryption technologies, including \cite{ManCryptsetup}:
\begin{itemize}
	\item LUKS and LUKS2 (see \autoref{chap:background.luks2});
	\item TrueCrypt and VeraCrypt (see \autoref{chap:otherapproaches.veracrypt});
	\item BitLocker (see \autoref{chap:otherapproaches.bitlocker}). The support for it is relatively new and still in experimental status.
\end{itemize}

For LUKS and LUKS2, there is additional functionality available, including formatting new partitions, upgrading a LUKS partition to LUKS2, and adding new keyslots (which have been described in \autoref{chap:background.luks2}) \cite{ManCryptsetup}.

To illustrate the usual workflow and explain some details ``hands-on'', we will use the following example: suppose we want to use the LUKS2-encrypted partition located at \texttt{/dev/sda1}. We will describe how to make the decrypted partition available, how to mount the contained file system, and how to unmount it and relock the partition again. For the first step, we will also take a look at parts of \texttt{cryptsetup}'s source code. This allows us to see what exactly is happening behind the scenes. We assume that no errors occur and that all supplied parameters, including the entered password, are correct. For the steps involving \texttt{cryptsetup}, please refer to \cite{ManCryptsetup} for more detailed information. See \autoref{chap:onlinereferences} for information on which version of \texttt{cryptsetup} the following paragraphs refer to.

\paragraph{Making the decrypted partition available}
From the user's perspective, this is not complex: we run \texttt{cryptsetup open /dev/sda1 crypto}. This instructs \texttt{cryptsetup} to decrypt the partition and make it available under the name \texttt{crypto} (we will see in a moment what role exactly this name plays). During the process, the user has to enter the password for one of the available keyslots. If the entered password matches a keyslot, the decrypted partition will be available at \texttt{/dev/mapper/crypto}. The last part of the path is specified by the name that we supplied when invoking the command.

Under the hood however, a lot of work gets done. After command line argument parsing, reading and verifying the on-disk header, and reading the password from the user, these are important parts of the source code:
\begin{enumerate}
	\item \texttt{luks2\_keyslot\_get\_key()} in \texttt{lib/luks2/luks2\_keyslot\_luks2.c}: this hashes the given password (l. 353), decrypts the keyslot area using the hash (l. 365), and merges the decrypted area (l. 370). The merged decrypted area is the derived master key.
	\item \texttt{\_open\_and\_verify()} in \texttt{lib/luks2/luks2\_keyslot.c}: this verifies the derived master key (l. 340).
	\item \texttt{get\_key\_description\_by\_digest()} in \texttt{lib/luks2/luks\_digest.c}: this creates the description for loading the key into the keyring. The description is always of the format \texttt{cryptsetup:<uuid>-<digest>}, where \texttt{uuid} is the UUID of the encrypted partition, and \texttt{digest} is the index of the digest (in the JSON array of digests) (l. 411).
	\item \texttt{\_open\_and\_activate()} in \texttt{lib/setup.c}: this adds the master key to the kernel keyring, if instructed to do so\footnote{\label{fn:otherapproaches.linux.keyring} This is the default behaviour (see \texttt{lib/libcryptsetup.h}, l. 733) and can be disabled with the \texttt{---disable-keyring} command line option \cite{ManCryptsetup}.} (l. 4003). Note that the type of the key is always \texttt{logon}, as can be seen in \texttt{crypt\_volume\_key\_load\_in\_keyring()} (l. 6081).
	\item \texttt{get\_dm\_crypt\_params()} in \texttt{lib/libdevmapper.c}: this creates the \texttt{dm-crypt} parameter string as described in \autoref{fig:otherapproaches.linux.dmcryptparameters} (l. 684). The key is either formatted as a keyring reference (l. 671) or hexadecimally (l. 675).
	\item \texttt{\_dm\_create\_device()} in \texttt{lib/libdevmapper.c}: this sends the parameters to the device mapper (l. 1390).
	\item \texttt{LUKS2\_activate()} in \texttt{lib/luks2/luks2\_json\_metadata.c}: this frees the memory containing the parameters sent to the device mapper (l. 2221), including the master key. The key gets overwritten with zeroes before being freed, with special care taken to avoid the compiler to optimize the zeroing out (see \texttt{crypt\_safe\_memzero()} in \texttt{lib/utils\_safe\_memory.c}).
\end{enumerate}

\paragraph{Mounting the contained file system}
This works like mounting any non-encrypted partition. The idea of \texttt{dm-crypt} is that the encryption is transparent, i.e. the newly created virtual device behaves just like a regular, non-encrypted partition. Mounting can therefore be achieved via \texttt{mount /dev/mapper/crypto <mount point>}.

\paragraph{Unmounting and relocking}
Unmounting, too, works as usual: \texttt{umount <mount point>}. Relocking the partition, i.e. removing the \texttt{/dev/mapper/crypto} mapping, can be achieved via \texttt{cryptsetup close crypto}.

\paragraph{Example of generated parameters} Finally, we present an example of complete \texttt{dm-crypt} parameters, as generated by \texttt{cryptsetup}. These are the parameters for a device encrypted with AES-XTS with two 256 bit keys\footnote{\label{fn:otherapproaches.linux.aesxtskeys} Recall from \autoref{chap:background.luks2.using} that the XTS mode needs two keys: a data encryption key and a tweak key.}: \texttt{aes-xts-plain64 <key> 0 /dev/sda1 32768}. The \texttt{key} parameter format depends on whether the kernel keyring is used or not:
\begin{itemize}
	\item \texttt{:64:logon:cryptsetup:59691c6c-a764-4c59-a876-cbc0c55802d5-d0} is a possible reference to a key in the keyring;
	\item \texttt{91bc1104b514053ae2420a09d0ba331fe8fa13acad6f9145697a5d28f2b7cb4a...} is the hexadecimal representation of the key (only the first 64 of the 128 characters are shown).
\end{itemize}

\section{VeraCrypt}
\label{chap:otherapproaches.veracrypt}

\section{BitLocker}
\label{chap:otherapproaches.bitlocker}
\todo{\cite{Kornblum2009} and \cite{Lewis2018} and \cite{Tuerpe2009} and \cite{Tan2020}}

\todo{\texttt{cryptsetup} has experimental support for BitLocker}

\todo{Use Ghidra and look at some of the code of \texttt{fvevol.sys}?}