\section{Other Approaches}
\label{chap:otherapproaches}
In this section, we describe both the Linux reference implementation of LUKS2 and the two disk encryption technologies that are featured in the performance comparison in \autoref{chap:performance}.

\subsection{Linux Kernel Implementation of LUKS2}
\label{chap:otherapproaches.linux}
To compare the architecture of our driver (see \autoref{chap:ourapproach.final}) to that of the Linux reference implementation, the latter will be described in this section. \todo{To see how the userspace part}\\\todo{of this implementation works, we will take a look at the source code of the \texttt{cryptsetup} tool.} The work of looking through the Linux kernel source code and creating a high-level overview has already been done in \cite{Korchagin2020}.

\subsubsection{The Linux Kernel Device Mapper}
\label{chap:otherapproaches.linux.dm}
The reference implementation uses the Linux kernel's Device Mapper \cite{Dmcrypt2020}. This is a kernel driver that allows creating virtual devices in layers. One such layer is known as a \emph{target}. A layer can be thought of as the Linux equivalent of a Windows file system filter driver\footnote{\label{fn:otherapproaches.linux.dmtargetdriver} This comparison holds as far as that the functionality of target is implemented by a kernel driver. It is also possible to implement new targets, as done e.g. in \cite{Barker2019}.}. The device mapper comes with many different available targets, including \cite{Linux}:
\begin{itemize}
	\item the \texttt{zero} target, which always returns zeroes for all reads and silently discards all writes. This is similar to Linux' \texttt{/dev/zero}, but in contrast to that this is a block device, not a character device\footnote{\label{fn:otherapproaches.linux.charvsblock} The difference is that character devices read and write a stream of individual byes, and block devices read and write blocks (usually 512 bytes) \cite{Corbet2005}.}.
	\item the \texttt{linear} target, which maps a range of blocks of the virtual device to an existing device. Described in more detail: ``map the block range $N$ to $N+L$ of the virtual device to the block range $M$ to $M+L$ of device $X$''. One virtual device can make use of multiple \texttt{linear} targets, e.g. the first half could be mapped to one device, and the second half to another device. \cite{Linux} lists further, and more concrete, examples.
	\item the \texttt{snapshot} target, which creates a copy-on-write snapshot of a device. These snapshots are ``mountable, saved states of the block device which are also writable without interfering with the original content.'' \cite{Linux}
	\item the \texttt{crypt} target, which performs transparent encryption of a device (writes are encrypted, reads are decrypted). This is what the LUKS2 reference implementation uses. The encryption is done via the Linux Kernel Crypto API, which offers a variety of different encryption schemes. This interface is described in more detail in \cite{Linux}.
\end{itemize}

The configuration of a virtual device happens via a \emph{mapping table}. The general format is described in \autoref{fig:otherapproaches.linux.mappingtable}, and \autoref{fig:otherapproaches.linux.dmcryptparameters} describes the parameter format for the \texttt{crypt} target.

Outside of the mapping table, the device mapper's targets are usually written with a \texttt{dm-} prefix, e.g. we write \texttt{dm-crypt} for the device mapper's \texttt{crypt} target.

\begin{figure}[htb!]
	\center
	\begin{mdframed}
		\texttt{<start block> <size> <target name> <target parameters>}
	\end{mdframed}
	\caption[
		Linux device mapper mapping table entry format
	]{
		Linux device mapper mapping table entry format (modified after \cite{Dmcrypt2020}). The \texttt{start block} is the first block of the virtual device that this mapping applies to. \texttt{size} indicates the number of blocks, including the start block, that this mapping is for. \texttt{target name} specifies the device mapper target that will be used. The \texttt{target parameters} are specific to each of the different targets. The \texttt{crypt} target's parameters are described in \autoref{fig:otherapproaches.linux.dmcryptparameters}.\\
		The full mapping for a virtual device can contain multiple entries, each in its own line. It is possible to combine different targets. The following example shows a 1024 block virtual device, whose first half is mapped using the \texttt{linear} target, and whose second half is mapped using the \texttt{crypt} target:\\
		\texttt{0\space\space\space{}512 linear <linear parameters>}\\
		\texttt{512 512 crypt\space\space{}<crypt parameters>}
	}
	\label{fig:otherapproaches.linux.mappingtable}
\end{figure}

\begin{figure}[htb!]
	\center
	\begin{mdframed}
		\texttt{<cipher> <key> <iv offset> <device path> <offset> [<\#opt> <opt>]}
	\end{mdframed}
	\caption[
		\texttt{dm-crypt} target parameter format
	]{
		\texttt{dm-crypt} target parameter format (modified after \cite{Dmcrypt2020}). \texttt{cipher} specifies the encryption cipher that is used, in the following format: \texttt{cipher-chainmode-ivmode[:ivopts]}. See \autoref{chap:background.luks2.using} for more on ciphers, chain modes (also known as block cipher modes), and IVs. \autoref{tbl:background.luks2.encryptionalgorithms} also lists examples of available encryption algorithms. \texttt{key} is the key used for the specified cipher. It can either be in hexadecimal notation, or a reference to a key in the kernel keyring (more on this shortly). The \texttt{iv offset} is a constant offset that is added to the sector number to create the IV. The \texttt{device path} determines the device the encrypted data is stored on, either by giving its path (e.g. \texttt{/dev/sda1}) or its major and minor number (e.g. \texttt{8:16}, see \cite{Corbet2005} for more on these). The \texttt{offset} gives the first sector on the specified device containing the encrypted data. Additionally, optional parameters can be specified after these required parameters, e.g. the disk's sector size, preceded by the count of optional parameters.
	}
	\label{fig:otherapproaches.linux.dmcryptparameters}
\end{figure}

\todo{explain kernel keyring mentioned in \autoref{fig:otherapproaches.linux.dmcryptparameters}}

\todo{mention \autoref{fig:otherapproaches.linux.dmcryptio}}

\begin{figure}[htb!]
	\center
	\small
	\begin{tikzpicture}[
		read/.style={
			arrow,
			very thick,
			draw=tBlue,
		},
		write/.style={
			arrow,
			very thick,
			draw=tPink,
		},
	]
		\node[rect, dashed, rounded corners=10pt, from={0, 1.5 to 6.5,  7}] {};
		\node[rect, dashed, rounded corners=10pt, from={8, 1.5 to 14.5, 7}] {};

		\foreach \x\y in {2.25/6,2.25/2,4/4,10.4/5.4,10.2/5.2,10/5} {
			\node[rect, draw=gray!70, fill=gray!30, minimum width=0.5cm, minimum height=0.5cm] at (\x,     \y) {};
			\node[rect, draw=gray!70, fill=gray!30, minimum width=0.5cm, minimum height=0.5cm] at (\x+0.5, \y) {};
			\node[rect, draw=gray!70, fill=gray!30, minimum width=0.5cm, minimum height=0.5cm] at (\x+1.0, \y) {};
			\node[rect, draw=gray!70, fill=gray!30, minimum width=0.5cm, minimum height=0.5cm] at (\x+1.5, \y) {};
		}

		\node[rect, draw=gray!70, fill=gray!30, from={1,    4   to 1.5,  4.5}] {};
		\node[rect, draw=gray!70, fill=red,     from={0.75, 3.5 to 1.25, 4}]   {};
		\node[rect, draw=gray!70, fill=black,   from={1.25, 3.5 to 1.75, 4}]   {};

		\node at (1.25,  4.75) {write\_tree};
		\node at (3,     2.5)  {dmcrypt\_write};
		\node at (3,     6.5)  {kcryptd\_io};
		\node at (4.7,   4.5)  {kcryptd};
		\node at (11.15, 5.9)  {cryptd};

		\node[anchor=north west, xshift=2pt, yshift=-2pt] at (0, 7) {\footnotesize\textit{dm-crypt}};
		\node[anchor=north west, xshift=2pt, yshift=-2pt] at (8, 7) {\footnotesize\textit{Crypto API}};

		\node[rect, fill=tOrng, rounded corners=4pt, from={4.75, 7.5 to 9.75, 8.5}] (fs)  {File system driver};
		\node[rect, fill=tPurp, rounded corners=4pt, from={4.75, 0   to 9.75, 1}]   (dev) {Device driver};

		\draw[read] (fs.west)    -| (4.375, 6)    -- (4, 6);
		\draw[read] (3, 5.75)    -- (3, 3)        -| (5.25, 1);
		\draw[read] (dev.east)   -| (10.25, 3.25) -| (4.75, 3.75);
		\draw[read] (5.5, 3.75)  -- (5.5, 3.5)    -| (11.5, 4.75);
		\draw[read] (11.9, 5.65) |- (fs.east);
		\node[anchor=east] at (4.375, 8) {\textcolor{tBlue!90!black}{read}};

		\draw[write] (fs.south)   |- (5.5, 5.875) -- (5.5, 4.25);
		\draw[write] (5.75, 4)    -| (10.5, 4.75);
		\draw[write] (9.75, 5)    -- (3.25, 5)    |- (1.5, 4.25);
		\draw[write] (1.25, 3.5)  |- (2, 2);
		\draw[write] (3.75, 1.75) |- (dev.west);
		\node[anchor=north west] at (fs.south) {\textcolor{tPink!90!black}{write}};
	\end{tikzpicture}
	\caption[
		\texttt{dm-crypt} and Linux kernel crypto IO traverse path
	]{
		\texttt{dm-crypt} and Linux kernel crypto IO traverse path (modified after \cite{Korchagin2020}). A write request from the file system driver first moves into the \texttt{kcryptd} workqueue. This queue takes care of doing the encryption at some later, more convenient point in time (see \cite{Linux} for more details). The Linux kernel crypto API does the actual encryption work, and it also may use internal queues. The encrypted write requests are then sorted by \texttt{dm-crypt} using a red-black tree and are sent to the device driver via another workqueue. \\
		For read requests, the encrypted data is retrieved from the device driver using the \texttt{kcryptd\_io} workqueue. When this data arrives, it is scheduled for decryption in the already mentioned \texttt{kcryptd} queue. When the kernel crypto API has done its work, the decrypted data is ready for the file system driver.
	}
	\label{fig:otherapproaches.linux.dmcryptio}
\end{figure}

\subsubsection{The \texttt{cryptsetup} Command Line Utility}
\label{chap:otherapproaches.linux.cryptsetup}
\todo{describe usual workflow of \texttt{cryptsetup} (luksFormat, open, close)}

In a simple use case the LUKS2 device contains only one encrypted segment. The whole mapping table then consists of just one line.\\\todo{\texttt{cryptsetup}'s purpose is to generate that line and send it to the device mapper.}

By default, \texttt{cryptsetup} uses the Linux kernel keyring. It uses the ``logon'' key type, which means that the key can only be read by the kernel and not by other user space programs. If explicitly instructed to do so, \texttt{cryptsetup} can also send the key directly to \texttt{dm-crypt}.

After creating the \texttt{dm-crypt} device, the key data that is still resident in user space memory is overwritten with zeroes.

\subsection{VeraCrypt}
\label{chap:otherapproaches.veracrypt}

\subsection{BitLocker}
\label{chap:otherapproaches.bitlocker}
\todo{\cite{Kornblum2009} and \cite{Lewis2018} and \cite{Tuerpe2009} and \cite{Tan2020}}

\todo{\texttt{cryptsetup} has experimental support for BitLocker}

\todo{Use Ghidra and look at some of the code of \texttt{fvevol.sys}?}