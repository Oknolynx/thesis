\section{Design and implementation of our approach}
\label{chap:ourapproach}

\subsection{Failed Attempts}
\label{chap:ourapproach.failed}
\todo{FilterManager framework}

\todo{Mention KMDF / UMDF and why we didn't use that if not already done in earlier section}

\subsection{The Final WDM Driver}
\label{chap:ourapproach.final}
\todo{Why WDM?}

\subsubsection{Architecture}
\label{chap:ourapproach.final.architecture}

\subsubsection{Initialization and Configuration}
\label{chap:ourapproach.final.init}
\todo{\texttt{luks2filterstart.exe}}

\subsubsection{De-/encrypting Reads and Writes}
\label{chap:ourapproach.final.de_encrypting}
\todo{custom AES implementation}

\todo{make sure this chapter and \autoref{chap:background.luks2.using} are not too similar}

LUKS2 supports many encryption algorithms (see \cite{Broz2018}, Table 4), but \texttt{luks2flt} only supports \texttt{aes-xts-plain64}.

\begin{ccode}
VOID
EncryptWriteBuffer(
    PUINT8 Buffer,
    PLUKS2_VOLUME_INFO VolInfo,
    PLUKS2_VOLUME_CRYPTO CryptoInfo,
    UINT64 OrigByteOffset,
    UINT64 Length
)
{
    UINT64 Sector = OrigByteOffset / VolInfo->SectorSize;
    UINT64 Offset = 0;
    UINT8 Tweak[16];

    while (Offset < Length) {
        ToLeBytes(Sector, Tweak);
        CryptoInfo->Encrypt(
            &CryptoInfo->Xts, Buffer + Offset,
            VolInfo->SectorSize, Tweak
        );
        Offset += VolInfo->SectorSize;
        Sector += 1;
    }
}
\end{ccode}

\subsubsection{Handling Other Request Types}
\label{chap:ourapproach.final.otherrequests}

\subsection{Security Considerations}
\label{chap:ourapproach.security}
\todo{How does \texttt{cryptsetup} send the master key to \texttt{dm-crypt}?}