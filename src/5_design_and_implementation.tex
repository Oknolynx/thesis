\chapter{Design and Implementation of Our Approach}
\label{chap:ourapproach}

\section{Failed Attempts}
\label{chap:ourapproach.failed}
\todo{FilterManager framework, mention fsrec driver and debugging}

\todo{Mention KMDF / UMDF and why we didn't use that if not already done in earlier section}

\todo{Mention other user space fs libraries, e.g. \url{https://github.com/dokan-dev/dokany}?}

\section{The Final WDM Driver}
\label{chap:ourapproach.final}
\todo{Why WDM?}

\subsection{Architecture}
\label{chap:ourapproach.final.architecture}
\todo{here and/or in other sections: screenshots from WinDbg showing e.g. a device stack and}\\\todo{luks2flt's device object}

\todo{Also screenshots from the registry showing the modified volume class' lower filters?}

\todo{compare to architecture of reference implementation, as promised in \autoref{chap:otherapproaches.linux}}

\todo{explain ``by the way''? or move to \autoref{chap:background.kerneldriver.concepts}}
\begin{itemize}
	\item INF files (page 485) (promised in \autoref{chap:background.kerneldriver.wdm}) (mention https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/infverif)?
	\item look-aside lists (page 331)
	\item communication between kernel and userspace via ports
\end{itemize}

\subsection{Initialization and Configuration}
\label{chap:ourapproach.final.init}
\todo{\texttt{luks2filterstart.exe}}

\todo{\texttt{DriverEntry} function, keep \autoref{fig:otherapproaches.bitlocker.driverentry} in mind}

\subsection{De-/encrypting Reads and Writes}
\label{chap:ourapproach.final.de_encrypting}
\todo{custom AES implementation, mention failed attempts of making existing crypto libraries work in kernel mode}

\todo{make sure this chapter and \autoref{chap:background.luks2.using} are not too similar}

LUKS2 supports many encryption algorithms (see \cite{Broz2018}, Table 4), but \texttt{luks2flt} only supports \texttt{aes-xts-plain64}.

\begin{ccode}
VOID
EncryptWriteBuffer(
    PUINT8 Buffer,
    PLUKS2_VOLUME_INFO VolInfo,
    PLUKS2_VOLUME_CRYPTO CryptoInfo,
    UINT64 OrigByteOffset,
    UINT64 Length
)
{
    UINT64 Sector = OrigByteOffset / VolInfo->SectorSize;
    UINT64 Offset = 0;
    UINT8 Tweak[16];

    while (Offset < Length) {
        ToLeBytes(Sector, Tweak);
        CryptoInfo->Encrypt(
            &CryptoInfo->Xts, Buffer + Offset,
            VolInfo->SectorSize, Tweak
        );
        Offset += VolInfo->SectorSize;
        Sector += 1;
    }
}
\end{ccode}

\subsection{Handling Other Request Types}
\label{chap:ourapproach.final.otherrequests}

\section{Security Considerations}
\label{chap:ourapproach.security}
\todo{reference \autoref{chap:otherapproaches.linux}?}

\todo{\url{https://crates.io/crates/secrecy}}

\todo{\cite{Halderman2008} \cite{Guan2018} \cite{Li2021} \cite{Simon2018}}

\todo{\url{https://tails.boum.org/contribute/design/memory_erasure/}}

\todo{\url{https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlsecurezeromemory}}

This is the generic solution written in C for clearing memory of the OpenSSL project (as of version 1.1.1l) \todo{[citation needed], explain \texttt{volatile}?}: \href{https://www.openssl.org/docs/man1.1.1/man3/OPENSSL_cleanse.html}{the doc for it}
\begin{ccode}
/*
 * Pointer to memset is volatile so that compiler must de-reference
 * the pointer and can't assume that it points to any function in
 * particular (such as memset, which it then might further "optimize")
 */
typedef void *(*memset_t)(void *, int, size_t);

static volatile memset_t memset_func = memset;

void OPENSSL_cleanse(void *ptr, size_t len)
{
    memset_func(ptr, 0, len);
}
\end{ccode}
The most popular CPU architectures, including x86, x64, ARM, and SPARC, have a hand-written assembly version of \texttt{OPENSSL\_cleanse}. This avoids the compiler from optimizing the zeroing away.